<!DOCTYPE html>
<html>
  <head>
	<meta charset="utf-8" />
    <title>Clojure Day 2</title>
  </head>
  <body style="width: 70%; margin-left: 15%;">
	<h3>第二天</h3>
    <ul>
	  <li>
		找Clojure中一些常用宏的实现
		<p>可以在GitHub中找到<a href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L455">一些常用宏的实现</a>
		</p>
	  </li>
	  <li>
		一个自定义延迟序列的例子
		<p>看到这么个例子：</p>
		<pre>
(defn recur-fibo [n]
    (letfn [(fib [current next n] (if (zero? n) current (recur next (+ current next) (dec n))))]
    (fib 0 1 n)))
		</pre>
		使用LazySeq后：
		<pre>
(defn lazy-seq-fibo
    ([] (concat [0 1] (lazy-seq-fibo 0 1)))
    ([a b] (let [n (+ a b)] (lazy-seq (cons n (lazy-seq-fibo b n))))))
		</pre>
	  </li>
	  <li>
		用宏实现一个包含else条件的unless
		<p>在使用普通的函数定义unless时，如：</p>
		<pre>
user=> (defn unless [test body] (if (not test) body))
#'user/unless
#会输出如下:
user=> (unless true (println "True!"))
True
nil
		</pre>
		<p>也就是说，先对代码块进行了求值，所以返回了True。因此，需要用到宏，使得扩展编程语言的时候能够避免执行一些函数。<br />而要实现else只需要将原来的nil替换为另外一个form。</p>
		<pre>
user=> (defmacro unless [expr form1 form2] (list 'if expr form2 form1))
#'user/unless
user=> (unless true (println "1") (println "2"))
2
nil
		</pre>
		如果要兼容原来的unless，就要考虑到两种不同的参数情况：
		<pre>
user=> (defmacro unless 
         ([expr form1 form2] (list 'if expr form2 form1))
         ([expr form] (list 'if expr nil form)))
#'user/unless
user=> (unless true (println "hello"))
nil
user=> (unless true (println "1") (println "2"))
2
nil
		</pre>
	  </li>
	  <li>
		编写一个类型用defrecord实现的协议
		<pre>
;; File Name: compass.clj
;; Open it in REPL with: (loaf-file "compass.clj")
;; 书中实现的Compass protocol与SimpleCompass record
;; 如最后一行toString是调用了java.lang.Object中的方法
;; 这样的好处就是可以与JVM上的其他类型相交互，即可以使用Java的类型和接口

(defprotocol Compass
  (direction [c])
  (left [c])
  (right [c]))

(def directions [:north :east :south :west])

(defn turn
  [base amount]
  (rem (+ base amount) (count directions)))

(defrecord SimpleCompass [bearing]
  Compass
  (direction [_] (directions bearing))
  (left [_] (SimpleCompass. (turn bearing 3)))
  (right [_] (SimpleCompass. (turn bearing 1)))
  Object
  (toString [this] (str "[" (direction this) "]")))

		</pre>
	  </li>
	</ul>
	<h4>参考</h4>
	<ol>
	  <li>
		<a href="http://blog.csdn.net/zh2qiang/article/details/7234487">Programming Clojure 学习笔记</a>
	  </li>
	</ol>
    <hr />
    <a href="Clojure_day_2.html"> Clojure day 2</a>| <a href="Clojure_day_3.html">Clojure day 3</a>
  </body>
</html>
